// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "@rescript/runtime/lib/es6/Belt_Int.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";

function pathToSegments(pathStr) {
  return Belt_List.fromArray(Belt_Array.keep(pathStr.split("/"), s => s !== ""));
}

function parseQuery(queryStr) {
  if (queryStr === "") {
    return;
  } else {
    return Belt_Array.reduce(queryStr.split("&"), undefined, (acc, pair) => {
      let match = pair.split("=");
      let len = match.length;
      if (len >= 3) {
        return acc;
      }
      switch (len) {
        case 0 :
          return acc;
        case 1 :
          let key = match[0];
          return Belt_MapString.set(acc, key, "");
        case 2 :
          let key$1 = match[0];
          let value = match[1];
          return Belt_MapString.set(acc, key$1, decodeURIComponent(value));
      }
    });
  }
}

function fromString(urlStr) {
  let match = urlStr.split("#");
  let len = match.length;
  let match$1;
  if (len >= 3) {
    match$1 = [
      urlStr,
      undefined
    ];
  } else {
    switch (len) {
      case 0 :
        match$1 = [
          urlStr,
          undefined
        ];
        break;
      case 1 :
        let main = match[0];
        match$1 = [
          main,
          undefined
        ];
        break;
      case 2 :
        let main$1 = match[0];
        let frag = match[1];
        match$1 = [
          main$1,
          frag
        ];
        break;
    }
  }
  let withoutFragment = match$1[0];
  let match$2 = withoutFragment.split("?");
  let len$1 = match$2.length;
  let match$3;
  if (len$1 >= 3) {
    match$3 = [
      withoutFragment,
      undefined
    ];
  } else {
    switch (len$1) {
      case 0 :
        match$3 = [
          withoutFragment,
          undefined
        ];
        break;
      case 1 :
        let path = match$2[0];
        match$3 = [
          path,
          undefined
        ];
        break;
      case 2 :
        let path$1 = match$2[0];
        let queryStr = match$2[1];
        match$3 = [
          path$1,
          parseQuery(queryStr)
        ];
        break;
    }
  }
  return {
    path: pathToSegments(match$3[0]),
    query: match$3[1],
    fragment: match$1[1]
  };
}

function fromLocation() {
  let pathname = window.location.pathname;
  let search = window.location.search;
  let hash = window.location.hash;
  let query = search.startsWith("?") ? parseQuery(search.slice(1)) : undefined;
  let fragment = hash.startsWith("#") && hash.length > 1 ? hash.slice(1) : undefined;
  return {
    path: pathToSegments(pathname),
    query: query,
    fragment: fragment
  };
}

function pathToString(url) {
  return "/" + Belt_List.toArray(url.path).join("/");
}

function toString(url) {
  let path = pathToString(url);
  let queryStr;
  if (Belt_MapString.isEmpty(url.query)) {
    queryStr = "";
  } else {
    let pairs = Belt_Array.map(Belt_MapString.toArray(url.query), param => param[0] + "=" + encodeURIComponent(param[1])).join("&");
    queryStr = "?" + pairs;
  }
  let f = url.fragment;
  let fragmentStr = f !== undefined ? "#" + f : "";
  return path + queryStr + fragmentStr;
}

function getQueryParam(url, key) {
  return Belt_MapString.get(url.query, key);
}

function getQueryParamInt(url, key) {
  return Belt_Option.flatMap(Belt_MapString.get(url.query, key), Belt_Int.fromString);
}

function getQueryParamBool(url, key) {
  return Belt_Option.map(Belt_MapString.get(url.query, key), v => {
    switch (v) {
      case "1" :
      case "true" :
        return true;
      default:
        return false;
    }
  });
}

function isRoot(url) {
  return url.path === /* [] */0;
}

export {
  fromString,
  fromLocation,
  toString,
  getQueryParam,
  getQueryParamInt,
  getQueryParamBool,
  isRoot,
  pathToString,
}
/* No side effect */
