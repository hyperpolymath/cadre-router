// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Navigation from "./Navigation.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function make(initialRoute) {
  return {
    currentRoute: initialRoute,
    state: {
      TAG: "Idle",
      _0: initialRoute
    },
    listeners: [],
    historyStack: [initialRoute],
    historyIndex: 0
  };
}

function notify(manager, event) {
  Belt_Array.forEach(manager.listeners, listener => listener(event));
}

function subscribe(manager, listener) {
  manager.listeners = Belt_Array.concat(manager.listeners, [listener]);
  return () => {
    manager.listeners = Belt_Array.keep(manager.listeners, l => l !== listener);
  };
}

function determineDirection(manager, newRoute, eq) {
  if (manager.historyIndex <= 0) {
    return "Forward";
  }
  let prevRoute = Belt_Array.get(manager.historyStack, manager.historyIndex - 1 | 0);
  if (prevRoute !== undefined && eq(Primitive_option.valFromOption(prevRoute), newRoute)) {
    return "Backward";
  } else {
    return "Forward";
  }
}

function startTransition(manager, newRoute, direction, eq) {
  let from = manager.currentRoute;
  if (eq(from, newRoute)) {
    return;
  }
  let dir = direction !== undefined ? direction : determineDirection(manager, newRoute, eq);
  manager.state = {
    TAG: "Transitioning",
    from: from,
    to: newRoute,
    direction: dir,
    progress: 0.0
  };
  notify(manager, {
    TAG: "TransitionStart",
    from: from,
    to: newRoute,
    direction: dir
  });
}

function updateProgress(manager, progress) {
  let t = manager.state;
  if (t.TAG === "Idle") {
    return;
  }
  manager.state = {
    TAG: "Transitioning",
    from: t.from,
    to: t.to,
    direction: t.direction,
    progress: progress
  };
  notify(manager, {
    TAG: "TransitionProgress",
    from: t.from,
    to: t.to,
    progress: progress
  });
}

function completeTransition(manager) {
  let match = manager.state;
  if (match.TAG === "Idle") {
    return;
  }
  let to = match.to;
  manager.currentRoute = to;
  manager.state = {
    TAG: "Idle",
    _0: to
  };
  switch (match.direction) {
    case "Forward" :
      manager.historyStack = Belt_Array.concat(Belt_Array.slice(manager.historyStack, 0, manager.historyIndex + 1 | 0), [to]);
      manager.historyIndex = manager.historyIndex + 1 | 0;
      break;
    case "Backward" :
      manager.historyIndex = Primitive_int.max(0, manager.historyIndex - 1 | 0);
      break;
    case "Replace" :
      Belt_Array.set(manager.historyStack, manager.historyIndex, to);
      break;
    case "Initial" :
      break;
  }
  notify(manager, {
    TAG: "TransitionEnd",
    from: match.from,
    to: to
  });
}

function cancelTransition(manager) {
  let match = manager.state;
  if (match.TAG === "Idle") {
    return;
  }
  let from = match.from;
  manager.state = {
    TAG: "Idle",
    _0: from
  };
  notify(manager, {
    TAG: "TransitionCancel",
    from: from,
    to: match.to
  });
}

function navigateTo(manager, route, eq) {
  startTransition(manager, route, undefined, eq);
  completeTransition(manager);
}

function isTransitioning(manager) {
  let match = manager.state;
  return match.TAG !== "Idle";
}

function getCurrentRoute(manager) {
  return manager.currentRoute;
}

function getState(manager) {
  return manager.state;
}

function linear(t) {
  return t;
}

function easeInOut(t) {
  if (t < 0.5) {
    return 2.0 * t * t;
  } else {
    return 1.0 - (-2.0 * t + 2.0) ** 2.0 / 2.0;
  }
}

function easeOut(t) {
  return 1.0 - (1.0 - t) ** 2.0;
}

function easeIn(t) {
  return t * t;
}

function animate(manager, newRoute, duration, easingOpt, eq, onComplete) {
  let easing = easingOpt !== undefined ? easingOpt : easeInOut;
  startTransition(manager, newRoute, undefined, eq);
  let startTime = {
    contents: undefined
  };
  let frameId = {
    contents: undefined
  };
  let loop = timestamp => {
    let s = startTime.contents;
    let start = s !== undefined ? s : (startTime.contents = timestamp, timestamp);
    let elapsed = timestamp - start;
    let rawProgress = Math.min(1.0, elapsed / duration);
    let easedProgress = easing(rawProgress);
    updateProgress(manager, easedProgress);
    if (rawProgress < 1.0) {
      frameId.contents = requestAnimationFrame(loop);
      return;
    } else {
      completeTransition(manager);
      if (onComplete !== undefined) {
        return onComplete();
      } else {
        return;
      }
    }
  };
  frameId.contents = requestAnimationFrame(loop);
  return () => {
    let id = frameId.contents;
    if (id !== undefined) {
      cancelAnimationFrame(id);
      return cancelTransition(manager);
    }
  };
}

let Animation = {
  linear: linear,
  easeInOut: easeInOut,
  easeOut: easeOut,
  easeIn: easeIn,
  animate: animate
};

function useTransition(manager) {
  let match = React.useState(() => manager.state);
  let setState = match[1];
  React.useEffect(() => subscribe(manager, event => {
    let exit = 0;
    switch (event.TAG) {
      case "TransitionStart" :
      case "TransitionProgress" :
        exit = 1;
        break;
      case "TransitionEnd" :
      case "TransitionCancel" :
        exit = 2;
        break;
    }
    switch (exit) {
      case 1 :
        return setState(param => manager.state);
      case 2 :
        return setState(param => manager.state);
    }
  }), [manager]);
  return match[0];
}

function useProgress(manager) {
  let state = useTransition(manager);
  if (state.TAG === "Idle") {
    return 0.0;
  } else {
    return state.progress;
  }
}

function useDirection(manager) {
  let state = useTransition(manager);
  if (state.TAG === "Idle") {
    return;
  } else {
    return state.direction;
  }
}

let React$1 = {
  useTransition: useTransition,
  useProgress: useProgress,
  useDirection: useDirection
};

function make$1(manager, parse, toString, eq, animationDurationOpt) {
  let animationDuration = animationDurationOpt !== undefined ? animationDurationOpt : 300.0;
  let push = route => {
    animate(manager, route, animationDuration, undefined, eq, () => Navigation.pushUrl(toString(route)));
  };
  let replace = route => {
    startTransition(manager, route, "Replace", eq);
    completeTransition(manager);
    Navigation.replaceUrl(toString(route));
  };
  let back = () => Navigation.back();
  let forward = () => Navigation.forward();
  let subscribeToNav = () => Navigation.onUrlChange(url => {
    let route = parse(url);
    if (route !== undefined) {
      animate(manager, Primitive_option.valFromOption(route), animationDuration, undefined, eq, undefined);
      return;
    }
  });
  return {
    push: push,
    replace: replace,
    back: back,
    forward: forward,
    subscribe: subscribeToNav
  };
}

let WithNavigation = {
  make: make$1
};

export {
  make,
  notify,
  subscribe,
  determineDirection,
  startTransition,
  updateProgress,
  completeTransition,
  cancelTransition,
  navigateTo,
  isTransitioning,
  getCurrentRoute,
  getState,
  Animation,
  React$1 as React,
  WithNavigation,
}
/* react Not a pure module */
