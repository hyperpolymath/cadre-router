// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Url from "./Url.js";
import * as Belt_Int from "@rescript/runtime/lib/es6/Belt_Int.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Float from "@rescript/runtime/lib/es6/Belt_Float.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function s(literal) {
  return state => {
    let match = state.remaining;
    if (match !== 0 && match.hd === literal) {
      return [
        undefined,
        {
          remaining: match.tl,
          url: state.url
        }
      ];
    }
  };
}

function str(state) {
  let match = state.remaining;
  if (match === 0) {
    return;
  }
  let head = match.hd;
  if (head !== "") {
    return [
      head,
      {
        remaining: match.tl,
        url: state.url
      }
    ];
  }
}

function int(state) {
  let match = state.remaining;
  if (match === 0) {
    return;
  }
  let n = Belt_Int.fromString(match.hd);
  if (n !== undefined) {
    return [
      n,
      {
        remaining: match.tl,
        url: state.url
      }
    ];
  }
}

function custom(parse) {
  return state => {
    let match = state.remaining;
    if (match === 0) {
      return;
    }
    let value = parse(match.hd);
    if (value !== undefined) {
      return [
        Primitive_option.valFromOption(value),
        {
          remaining: match.tl,
          url: state.url
        }
      ];
    }
  };
}

function top(state) {
  let match = state.remaining;
  if (match !== 0) {
    return;
  } else {
    return [
      undefined,
      state
    ];
  }
}

function andThen(parserA, parserB) {
  return state => {
    let match = parserA(state);
    if (match === undefined) {
      return;
    }
    let match$1 = parserB(match[1]);
    if (match$1 !== undefined) {
      return [
        [
          match[0],
          match$1[0]
        ],
        match$1[1]
      ];
    }
  };
}

function map(parser, fn) {
  return state => {
    let match = parser(state);
    if (match !== undefined) {
      return [
        fn(match[0]),
        match[1]
      ];
    }
  };
}

function $less$$great(fn, parser) {
  return map(parser, fn);
}

function oneOf(parsers) {
  return state => {
    let result;
    let i = 0;
    let len = parsers.length;
    while (result === undefined && i < len) {
      let parser = Belt_Array.get(parsers, i);
      if (parser !== undefined) {
        let success = parser(state);
        if (success !== undefined) {
          result = success;
        } else {
          i = i + 1 | 0;
        }
      } else {
        i = i + 1 | 0;
      }
    };
    return result;
  };
}

function optional(parser) {
  return state => {
    let match = parser(state);
    if (match !== undefined) {
      return [
        Primitive_option.some(match[0]),
        match[1]
      ];
    } else {
      return [
        undefined,
        state
      ];
    }
  };
}

function query(key) {
  return state => {
    let value = Url.getQueryParam(state.url, key);
    return [
      value,
      state
    ];
  };
}

function queryInt(key) {
  return state => {
    let value = Url.getQueryParamInt(state.url, key);
    return [
      value,
      state
    ];
  };
}

function queryBool(key) {
  return state => {
    let value = Url.getQueryParamBool(state.url, key);
    return [
      value,
      state
    ];
  };
}

function queryRequired(key) {
  return state => {
    let value = Url.getQueryParam(state.url, key);
    if (value !== undefined) {
      return [
        value,
        state
      ];
    }
  };
}

let uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;

function uuid(state) {
  let match = state.remaining;
  if (match === 0) {
    return;
  }
  let head = match.hd;
  if (uuidRegex.test(head)) {
    return [
      head,
      {
        remaining: match.tl,
        url: state.url
      }
    ];
  }
}

let slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;

function slug(state) {
  let match = state.remaining;
  if (match === 0) {
    return;
  }
  let head = match.hd;
  if (slugRegex.test(head)) {
    return [
      head,
      {
        remaining: match.tl,
        url: state.url
      }
    ];
  }
}

function float(state) {
  let match = state.remaining;
  if (match === 0) {
    return;
  }
  let f = Belt_Float.fromString(match.hd);
  if (f !== undefined) {
    return [
      f,
      {
        remaining: match.tl,
        url: state.url
      }
    ];
  }
}

function $$enum(options) {
  return state => {
    let match = state.remaining;
    if (match === 0) {
      return;
    }
    let head = match.hd;
    if (Belt_Array.some(options, opt => opt === head)) {
      return [
        head,
        {
          remaining: match.tl,
          url: state.url
        }
      ];
    }
  };
}

function regex(re) {
  return state => {
    let match = state.remaining;
    if (match === 0) {
      return;
    }
    let head = match.hd;
    if (re.test(head)) {
      return [
        head,
        {
          remaining: match.tl,
          url: state.url
        }
      ];
    }
  };
}

function rest(state) {
  return [
    state.remaining,
    {
      remaining: /* [] */0,
      url: state.url
    }
  ];
}

function restAsString(state) {
  let joined = Belt_List.toArray(state.remaining).join("/");
  return [
    joined,
    {
      remaining: /* [] */0,
      url: state.url
    }
  ];
}

function fragment(state) {
  return [
    state.url.fragment,
    state
  ];
}

function fragmentRequired(state) {
  let f = state.url.fragment;
  if (f !== undefined) {
    return [
      f,
      state
    ];
  }
}

function succeed(value) {
  return state => [
    value,
    state
  ];
}

function fail(param) {
  
}

function lazy_(thunk) {
  return state => thunk()(state);
}

function filter(parser, predicate) {
  return state => {
    let match = parser(state);
    if (match === undefined) {
      return;
    }
    let value = match[0];
    if (predicate(value)) {
      return [
        value,
        match[1]
      ];
    }
  };
}

function withDefault(parser, $$default) {
  return state => {
    let result = parser(state);
    if (result !== undefined) {
      return result;
    } else {
      return [
        $$default,
        state
      ];
    }
  };
}

function attempt(parser) {
  return state => {
    let result = parser(state);
    if (result !== undefined) {
      return result;
    }
  };
}

function debug(label, parser) {
  return state => {
    console.log(`[Parser Debug: ` + label + `]`);
    console.log(`  Remaining: ` + Belt_List.toArray(state.remaining).join("/"));
    let result = parser(state);
    if (result !== undefined) {
      console.log(`  Result: Success`);
      console.log(`  Consumed: ` + String(Belt_List.length(state.remaining) - Belt_List.length(result[1].remaining) | 0) + ` segments`);
    } else {
      console.log(`  Result: Failed`);
    }
    return result;
  };
}

function parse(parser, url) {
  let initialState_remaining = url.path;
  let initialState = {
    remaining: initialState_remaining,
    url: url
  };
  let match = parser(initialState);
  if (match === undefined) {
    return;
  }
  let match$1 = match[1].remaining;
  if (match$1 !== 0) {
    return;
  } else {
    return Primitive_option.some(match[0]);
  }
}

function parsePartial(parser, url) {
  let initialState_remaining = url.path;
  let initialState = {
    remaining: initialState_remaining,
    url: url
  };
  let match = parser(initialState);
  if (match !== undefined) {
    return Primitive_option.some(match[0]);
  }
}

function parseWithError(parser, url) {
  let initialState_remaining = url.path;
  let initialState = {
    remaining: initialState_remaining,
    url: url
  };
  let match = parser(initialState);
  if (match === undefined) {
    return {
      TAG: "Error",
      _0: {
        remainingPath: url.path,
        consumedPath: /* [] */0,
        url: url
      }
    };
  }
  let remaining = match[1].remaining;
  if (remaining === 0) {
    return {
      TAG: "Ok",
      _0: match[0]
    };
  }
  let consumedCount = Belt_List.length(url.path) - Belt_List.length(remaining) | 0;
  let consumed = Belt_Option.getWithDefault(Belt_List.take(url.path, consumedCount), /* [] */0);
  return {
    TAG: "Error",
    _0: {
      remainingPath: remaining,
      consumedPath: consumed,
      url: url
    }
  };
}

let $less$slash$great = andThen;

export {
  s,
  str,
  int,
  custom,
  top,
  andThen,
  $less$slash$great,
  map,
  $less$$great,
  oneOf,
  optional,
  query,
  queryInt,
  queryBool,
  queryRequired,
  uuid,
  slug,
  float,
  $$enum,
  regex,
  rest,
  restAsString,
  fragment,
  fragmentRequired,
  succeed,
  fail,
  lazy_,
  filter,
  withDefault,
  attempt,
  debug,
  parse,
  parsePartial,
  parseWithError,
}
/* No side effect */
