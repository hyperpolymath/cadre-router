// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Parser from "./Parser.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";

function findInTree(tree, target, eq, currentPath) {
  if (tree.TAG === "Leaf") {
    let route = tree._0;
    if (eq(route, target)) {
      return {
        segments: Belt_List.toArray(Belt_List.reverse(currentPath)),
        leaf: route
      };
    } else {
      return;
    }
  }
  let children = tree.children;
  let route$1 = tree.route;
  if (eq(route$1, target)) {
    return {
      segments: Belt_List.toArray(Belt_List.reverse(currentPath)),
      leaf: route$1
    };
  }
  let newPath = {
    hd: route$1,
    tl: currentPath
  };
  let result;
  let i = 0;
  let len = children.length;
  while (result === undefined && i < len) {
    let child = Belt_Array.get(children, i);
    if (child !== undefined) {
      let found = findInTree(child, target, eq, newPath);
      if (found !== undefined) {
        result = found;
      } else {
        i = i + 1 | 0;
      }
    } else {
      i = i + 1 | 0;
    }
  };
  return result;
}

function make(tree, parse, toString, eq) {
  return {
    tree: tree,
    parse: parse,
    toString: toString,
    eq: eq
  };
}

function getLayoutPath(def, route) {
  return findInTree(def.tree, route, def.eq, /* [] */0);
}

function getLayoutContexts(def, route) {
  let match = getLayoutPath(def, route);
  if (match === undefined) {
    return [];
  }
  let segments = match.segments;
  let parentContexts = Belt_Array.mapWithIndex(segments, (i, r) => ({
    route: r,
    depth: i,
    isLeaf: false
  }));
  let leafContext_route = match.leaf;
  let leafContext_depth = segments.length;
  let leafContext = {
    route: leafContext_route,
    depth: leafContext_depth,
    isLeaf: true
  };
  return Belt_Array.concat(parentContexts, [leafContext]);
}

function leaf(route) {
  return {
    TAG: "Leaf",
    _0: route
  };
}

function branch(route, children) {
  return {
    TAG: "Branch",
    route: route,
    children: children
  };
}

function index(parent, indexRoute, children) {
  return {
    TAG: "Branch",
    route: parent,
    children: Belt_Array.concat([{
        TAG: "Leaf",
        _0: indexRoute
      }], children)
  };
}

function NestedRoute$React$outlet(props) {
  let __fallback = props.fallback;
  let context = props.context;
  let fallback = __fallback !== undefined ? __fallback : null;
  let nextLayout = Belt_Array.get(context.remainingLayouts, 0);
  if (nextLayout !== undefined) {
    return context.renderLayout(nextLayout);
  } else {
    return fallback;
  }
}

function nextOutletContext(context) {
  return {
    remainingLayouts: Belt_Array.sliceToEnd(context.remainingLayouts, 1),
    renderLayout: context.renderLayout
  };
}

function Make(Config) {
  let NestedRoute$React$Make = props => {
    let layouts = getLayoutContexts(Config.definition, props.route);
    if (layouts.length === 0) {
      return Config.renderNotFound();
    }
    let renderAtDepth = idx => {
      let layout = Belt_Array.get(layouts, idx);
      if (layout === undefined) {
        return null;
      }
      let outletCtx_remainingLayouts = Belt_Array.sliceToEnd(layouts, idx + 1 | 0);
      let outletCtx_renderLayout = ctx => {
        let nextIdx = Belt_Array.getIndexBy(layouts, l => Config.definition.eq(l.route, ctx.route));
        if (nextIdx !== undefined) {
          return renderAtDepth(nextIdx);
        } else {
          return null;
        }
      };
      let outletCtx = {
        remainingLayouts: outletCtx_remainingLayouts,
        renderLayout: outletCtx_renderLayout
      };
      return Config.renderLayout(layout, outletCtx);
    };
    return renderAtDepth(0);
  };
  return {
    make: NestedRoute$React$Make
  };
}

let React = {
  outlet: NestedRoute$React$outlet,
  nextOutletContext: nextOutletContext,
  Make: Make
};

function nestedParser(parentParser, childParser, combine) {
  return Parser.map(Parser.andThen(parentParser, childParser), param => combine(param[0], param[1]));
}

function optionalChild(parentParser, childParser, parentOnly, withChild) {
  return Parser.oneOf([
    Parser.map(Parser.andThen(parentParser, childParser), param => withChild(param[0], param[1])),
    Parser.map(Parser.andThen(parentParser, Parser.top), param => parentOnly(param[0]))
  ]);
}

export {
  findInTree,
  make,
  getLayoutPath,
  getLayoutContexts,
  leaf,
  branch,
  index,
  React,
  nestedParser,
  optionalChild,
}
/* No side effect */
