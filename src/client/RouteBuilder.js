// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Parser from "./Parser.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function lit(literal) {
  return {
    parser: Parser.s(literal),
    serializer: () => ({
      hd: literal,
      tl: /* [] */0
    })
  };
}

function str() {
  return {
    parser: Parser.str,
    serializer: s => ({
      hd: s,
      tl: /* [] */0
    })
  };
}

function int() {
  return {
    parser: Parser.int,
    serializer: n => ({
      hd: String(n),
      tl: /* [] */0
    })
  };
}

function custom(parse, serialize) {
  return {
    parser: Parser.custom(parse),
    serializer: a => ({
      hd: serialize(a),
      tl: /* [] */0
    })
  };
}

function andThen(segA, segB) {
  return {
    parser: Parser.andThen(segA.parser, segB.parser),
    serializer: param => Belt_List.concat(segA.serializer(param[0]), segB.serializer(param[1]))
  };
}

function end__serializer() {
  return /* [] */0;
}

let end_ = {
  parser: Parser.top,
  serializer: end__serializer
};

function build(seg, toRoute, fromRoute) {
  return {
    parse: url => {
      let fullParser = Parser.map(Parser.andThen(seg.parser, Parser.top), param => param[0]);
      let a = Parser.parse(fullParser, url);
      if (a !== undefined) {
        return Primitive_option.some(toRoute(Primitive_option.valFromOption(a)));
      }
    },
    toString: route => {
      let a = fromRoute(route);
      if (a === undefined) {
        return;
      }
      let segments = seg.serializer(Primitive_option.valFromOption(a));
      return "/" + Belt_List.toArray(segments).join("/");
    }
  };
}

function oneOf(routes) {
  return {
    parse: url => {
      let result;
      let i = 0;
      let len = routes.length;
      while (result === undefined && i < len) {
        let r = Belt_Array.get(routes, i);
        if (r !== undefined) {
          let success = r.parse(url);
          if (success !== undefined) {
            result = success;
          } else {
            i = i + 1 | 0;
          }
        } else {
          i = i + 1 | 0;
        }
      };
      return result;
    },
    toString: route => {
      let result;
      let i = 0;
      let len = routes.length;
      while (result === undefined && i < len) {
        let r = Belt_Array.get(routes, i);
        if (r !== undefined) {
          let success = r.toString(route);
          if (success !== undefined) {
            result = success;
          } else {
            i = i + 1 | 0;
          }
        } else {
          i = i + 1 | 0;
        }
      };
      return result;
    }
  };
}

let $slash$great = andThen;

function Make(funarg) {
  let parseOption = url => funarg.definition.parse(url);
  let parse = url => {
    let route = funarg.definition.parse(url);
    if (route !== undefined) {
      return Primitive_option.valFromOption(route);
    } else {
      return funarg.notFound;
    }
  };
  let toString = route => {
    let s = funarg.definition.toString(route);
    if (s !== undefined) {
      return s;
    } else {
      return "/";
    }
  };
  return {
    parse: parse,
    parseOption: parseOption,
    toString: toString
  };
}

export {
  lit,
  str,
  int,
  custom,
  andThen,
  $slash$great,
  end_,
  build,
  oneOf,
  Make,
}
/* No side effect */
