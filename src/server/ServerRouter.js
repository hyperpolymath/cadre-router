// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Url from "../client/Url.js";
import * as Parser from "../client/Parser.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Js_promise from "@rescript/runtime/lib/es6/Js_promise.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function methodFromString(s) {
  let match = s.toUpperCase();
  switch (match) {
    case "DELETE" :
      return "DELETE";
    case "GET" :
      return "GET";
    case "HEAD" :
      return "HEAD";
    case "OPTIONS" :
      return "OPTIONS";
    case "PATCH" :
      return "PATCH";
    case "POST" :
      return "POST";
    case "PUT" :
      return "PUT";
    default:
      return;
  }
}

function methodToString(m) {
  switch (m) {
    case "GET" :
      return "GET";
    case "POST" :
      return "POST";
    case "PUT" :
      return "PUT";
    case "PATCH" :
      return "PATCH";
    case "DELETE" :
      return "DELETE";
    case "HEAD" :
      return "HEAD";
    case "OPTIONS" :
      return "OPTIONS";
  }
}

function makeContext(urlString, method, headersOpt, param) {
  let headers = headersOpt !== undefined ? Primitive_option.valFromOption(headersOpt) : undefined;
  let url = Url.fromString(urlString);
  return {
    url: url,
    method: method,
    headers: headers,
    path: "/" + Belt_List.toArray(url.path).join("/")
  };
}

function make(parser, methodsOpt, handler) {
  let methods = methodsOpt !== undefined ? methodsOpt : ["GET"];
  return {
    parse: ctx => Parser.parse(parser, ctx.url),
    methods: methods,
    handler: handler
  };
}

function matchRoute(route, ctx) {
  let parsed = route.parse(ctx);
  if (parsed === undefined) {
    return "NoMatch";
  }
  let methodAllowed = Belt_Array.some(route.methods, m => m === ctx.method);
  if (methodAllowed) {
    return {
      TAG: "Matched",
      _0: route.handler(Primitive_option.valFromOption(parsed), ctx)
    };
  } else {
    return {
      TAG: "WrongMethod",
      _0: route.methods
    };
  }
}

function router(routes, notFound) {
  return {
    routes: routes,
    routeArray: routes,
    notFoundHandler: notFound
  };
}

function route(router, ctx) {
  let result;
  let allowedMethods = [];
  let i = 0;
  let len = router.routeArray.length;
  while (result === undefined && i < len) {
    let r = Belt_Array.get(router.routeArray, i);
    if (r !== undefined) {
      let handlerResult = matchRoute(r, ctx);
      if (typeof handlerResult !== "object") {
        i = i + 1 | 0;
      } else if (handlerResult.TAG === "Matched") {
        result = handlerResult._0;
      } else {
        allowedMethods = Belt_Array.concat(allowedMethods, handlerResult._0);
        i = i + 1 | 0;
      }
    } else {
      i = i + 1 | 0;
    }
  };
  let r$1 = result;
  if (r$1 !== undefined) {
    return r$1;
  } else if (allowedMethods.length !== 0) {
    return {
      TAG: "MethodNotAllowed",
      _0: allowedMethods
    };
  } else {
    return "NotFound";
  }
}

function MakeIsomorphic(Config) {
  let handleRequest = ctx => {
    let route = Parser.parse(Config.parser, ctx.url);
    if (route !== undefined) {
      let route$1 = Primitive_option.valFromOption(route);
      let __x = Config.fetchData(route$1, ctx);
      let __x$1 = Js_promise.then_(data => {
        let ssrCtx_url = ctx.url;
        let ssrCtx_headers = ctx.headers;
        let ssrCtx = {
          route: route$1,
          data: data,
          url: ssrCtx_url,
          headers: ssrCtx_headers
        };
        return Promise.resolve({
          TAG: "Render",
          _0: Config.render(ssrCtx)
        });
      }, __x);
      return Js_promise.$$catch(err => {
        let m = err.message;
        let msg = m !== undefined ? m : "Unknown error";
        return Promise.resolve({
          TAG: "ServerError",
          _0: msg
        });
      }, __x$1);
    }
    let __x$2 = Config.fetchData(Config.notFoundRoute, ctx);
    let __x$3 = Js_promise.then_(data => {
      let ssrCtx_route = Config.notFoundRoute;
      let ssrCtx_url = ctx.url;
      let ssrCtx_headers = ctx.headers;
      let ssrCtx = {
        route: ssrCtx_route,
        data: data,
        url: ssrCtx_url,
        headers: ssrCtx_headers
      };
      return Promise.resolve({
        TAG: "Render",
        _0: Config.render(ssrCtx)
      });
    }, __x$2);
    return Js_promise.$$catch(param => Promise.resolve("NotFound"), __x$3);
  };
  let hydrateUrl = urlString => Parser.parse(Config.parser, Url.fromString(urlString));
  return {
    handleRequest: handleRequest,
    hydrateUrl: hydrateUrl
  };
}

function extractParams(url) {
  return Belt_List.toArray(url.path);
}

function redirectWithQuery(newPath, url) {
  let queryString = Url.toString({
    path: /* [] */0,
    query: url.query,
    fragment: undefined
  });
  if (queryString.length > 1) {
    return newPath + queryString;
  } else {
    return newPath;
  }
}

export {
  methodFromString,
  methodToString,
  makeContext,
  make,
  matchRoute,
  router,
  route,
  MakeIsomorphic,
  extractParams,
  redirectWithQuery,
}
/* No side effect */
