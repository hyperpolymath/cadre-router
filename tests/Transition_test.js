// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Transition from "../src/client/Transition.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";

function assertEq(name, actual, expected) {
  if (Primitive_object.equal(actual, expected)) {
    console.log(`[PASS] ` + name);
  } else {
    console.error(`[FAIL] ` + name);
    console.error(`  Expected: ` + Belt_Option.getWithDefault(JSON.stringify(expected), "?"));
    console.error(`  Actual:   ` + Belt_Option.getWithDefault(JSON.stringify(actual), "?"));
  }
}

function assertTrue(name, actual) {
  if (actual) {
    console.log(`[PASS] ` + name);
  } else {
    console.error(`[FAIL] ` + name + ` - expected true`);
  }
}

function assertFalse(name, actual) {
  if (actual) {
    console.error(`[FAIL] ` + name + ` - expected false`);
  } else {
    console.log(`[PASS] ` + name);
  }
}

function routeEq(a, b) {
  return a === b;
}

function testMakeManager() {
  let manager = Transition.make("Home");
  assertEq("make: initial route", Transition.getCurrentRoute(manager), "Home");
  assertFalse("make: not transitioning", Transition.isTransitioning(manager));
}

function testGetState() {
  let manager = Transition.make("Home");
  let state = Transition.getState(manager);
  if (state.TAG === "Idle") {
    return assertEq("getState: idle with initial route", state._0, "Home");
  }
  console.error("[FAIL] getState: should be Idle");
}

function testStartTransition() {
  let manager = Transition.make("Home");
  Transition.startTransition(manager, "About", undefined, routeEq);
  assertTrue("startTransition: is transitioning", Transition.isTransitioning(manager));
  let match = Transition.getState(manager);
  if (match.TAG === "Idle") {
    console.error("[FAIL] startTransition: should be Transitioning");
    return;
  }
  assertEq("startTransition: from", match.from, "Home");
  assertEq("startTransition: to", match.to, "About");
  assertEq("startTransition: direction", match.direction, "Forward");
}

function testStartTransitionSameRoute() {
  let manager = Transition.make("Home");
  Transition.startTransition(manager, "Home", undefined, routeEq);
  assertFalse("startTransition same: not transitioning", Transition.isTransitioning(manager));
}

function testUpdateProgress() {
  let manager = Transition.make("Home");
  Transition.startTransition(manager, "About", undefined, routeEq);
  Transition.updateProgress(manager, 0.5);
  let match = Transition.getState(manager);
  if (match.TAG !== "Idle") {
    return assertEq("updateProgress: progress value", match.progress, 0.5);
  }
  console.error("[FAIL] updateProgress: should be Transitioning");
}

function testCompleteTransition() {
  let manager = Transition.make("Home");
  Transition.startTransition(manager, "About", undefined, routeEq);
  Transition.completeTransition(manager);
  assertFalse("completeTransition: not transitioning", Transition.isTransitioning(manager));
  assertEq("completeTransition: current route updated", Transition.getCurrentRoute(manager), "About");
  let r = Transition.getState(manager);
  if (r.TAG === "Idle") {
    return assertEq("completeTransition: idle with new route", r._0, "About");
  }
  console.error("[FAIL] completeTransition: should be Idle");
}

function testCancelTransition() {
  let manager = Transition.make("Home");
  Transition.startTransition(manager, "About", undefined, routeEq);
  Transition.cancelTransition(manager);
  assertFalse("cancelTransition: not transitioning", Transition.isTransitioning(manager));
  assertEq("cancelTransition: route unchanged", Transition.getCurrentRoute(manager), "Home");
}

function testNavigateTo() {
  let manager = Transition.make("Home");
  Transition.navigateTo(manager, "Contact", routeEq);
  assertFalse("navigateTo: not transitioning (instant)", Transition.isTransitioning(manager));
  assertEq("navigateTo: route updated", Transition.getCurrentRoute(manager), "Contact");
}

function testDirectionForward() {
  let manager = Transition.make("Home");
  Transition.navigateTo(manager, "About", routeEq);
  Transition.startTransition(manager, "Contact", undefined, routeEq);
  let match = Transition.getState(manager);
  if (match.TAG === "Idle") {
    console.error("[FAIL] direction: should be Transitioning");
  } else {
    assertEq("direction: forward for new route", match.direction, "Forward");
  }
  Transition.completeTransition(manager);
}

function testDirectionBackward() {
  let manager = Transition.make("Home");
  Transition.navigateTo(manager, "About", routeEq);
  Transition.navigateTo(manager, "Contact", routeEq);
  Transition.startTransition(manager, "About", undefined, routeEq);
  let match = Transition.getState(manager);
  if (match.TAG !== "Idle") {
    return assertEq("direction: backward for previous route", match.direction, "Backward");
  }
  console.error("[FAIL] direction: should be Transitioning");
}

function testExplicitDirection() {
  let manager = Transition.make("Home");
  Transition.startTransition(manager, "About", "Replace", routeEq);
  let match = Transition.getState(manager);
  if (match.TAG !== "Idle") {
    return assertEq("explicit direction: uses provided direction", match.direction, "Replace");
  }
  console.error("[FAIL] explicit direction: should be Transitioning");
}

function testSubscribe() {
  let manager = Transition.make("Home");
  let events = {
    contents: []
  };
  let unsubscribe = Transition.subscribe(manager, event => {
    events.contents = Belt_Array.concat(events.contents, [event]);
  });
  Transition.startTransition(manager, "About", undefined, routeEq);
  Transition.updateProgress(manager, 0.5);
  Transition.completeTransition(manager);
  assertEq("subscribe: received 3 events", events.contents.length, 3);
  unsubscribe();
  Transition.navigateTo(manager, "Contact", routeEq);
  assertEq("unsubscribe: no more events", events.contents.length, 3);
}

function testSubscribeCancel() {
  let manager = Transition.make("Home");
  let cancelled = {
    contents: false
  };
  Transition.subscribe(manager, event => {
    if (event.TAG === "TransitionCancel") {
      cancelled.contents = true;
      return;
    }
  });
  Transition.startTransition(manager, "About", undefined, routeEq);
  Transition.cancelTransition(manager);
  assertTrue("subscribe cancel: received cancel event", cancelled.contents);
}

function testEasingLinear() {
  assertEq("easing linear 0", Transition.Animation.linear(0.0), 0.0);
  assertEq("easing linear 0.5", Transition.Animation.linear(0.5), 0.5);
  assertEq("easing linear 1", Transition.Animation.linear(1.0), 1.0);
}

function testEasingBounds() {
  let easings = [
    [
      "linear",
      Transition.Animation.linear
    ],
    [
      "easeIn",
      Transition.Animation.easeIn
    ],
    [
      "easeOut",
      Transition.Animation.easeOut
    ],
    [
      "easeInOut",
      Transition.Animation.easeInOut
    ]
  ];
  Belt_Array.forEach(easings, param => {
    let fn = param[1];
    let name = param[0];
    let at0 = fn(0.0);
    let at1 = fn(1.0);
    if (Math.abs(at0) < 0.0001) {
      console.log(`[PASS] ` + name + ` at 0`);
    } else {
      console.error(`[FAIL] ` + name + ` at 0: got ` + String(at0));
    }
    if (Math.abs(at1 - 1.0) < 0.0001) {
      console.log(`[PASS] ` + name + ` at 1`);
    } else {
      console.error(`[FAIL] ` + name + ` at 1: got ` + String(at1));
    }
  });
}

function runTests() {
  console.log("=== Transition Tests ===");
  testMakeManager();
  testGetState();
  testStartTransition();
  testStartTransitionSameRoute();
  testUpdateProgress();
  testCompleteTransition();
  testCancelTransition();
  testNavigateTo();
  testDirectionForward();
  testDirectionBackward();
  testExplicitDirection();
  testSubscribe();
  testSubscribeCancel();
  testEasingLinear();
  testEasingBounds();
  console.log("=== Transition Tests Complete ===");
}

runTests();

export {
  assertEq,
  assertTrue,
  assertFalse,
  routeEq,
  testMakeManager,
  testGetState,
  testStartTransition,
  testStartTransitionSameRoute,
  testUpdateProgress,
  testCompleteTransition,
  testCancelTransition,
  testNavigateTo,
  testDirectionForward,
  testDirectionBackward,
  testExplicitDirection,
  testSubscribe,
  testSubscribeCancel,
  testEasingLinear,
  testEasingBounds,
  runTests,
}
/*  Not a pure module */
