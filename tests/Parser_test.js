// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Url from "../src/client/Url.js";
import * as Parser from "../src/client/Parser.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";

function assertEq(name, actual, expected) {
  if (Primitive_object.equal(actual, expected)) {
    console.log(`[PASS] ` + name);
  } else {
    console.error(`[FAIL] ` + name);
    console.error(`  Expected: ` + Belt_Option.getWithDefault(JSON.stringify(expected), "?"));
    console.error(`  Actual:   ` + Belt_Option.getWithDefault(JSON.stringify(actual), "?"));
  }
}

function assertSome(name, actual) {
  if (actual !== undefined) {
    console.log(`[PASS] ` + name);
  } else {
    console.error(`[FAIL] ` + name + ` - expected Some, got None`);
  }
}

function assertNone(name, actual) {
  if (actual !== undefined) {
    console.error(`[FAIL] ` + name + ` - expected None, got Some`);
  } else {
    console.log(`[PASS] ` + name);
  }
}

function fromString(s) {
  if (s.length > 0 && s.length < 20) {
    return {
      TAG: "TestId",
      _0: s
    };
  }
}

function toString(s) {
  return s._0;
}

let parser = Parser.custom(fromString);

let TestId = {
  fromString: fromString,
  toString: toString,
  parser: parser
};

function testLiteralMatch() {
  let parser = Parser.s("profile");
  let url = Url.fromString("/profile");
  assertSome("s: matches literal", Parser.parse(parser, url));
}

function testLiteralNoMatch() {
  let parser = Parser.s("profile");
  let url = Url.fromString("/settings");
  assertNone("s: rejects non-matching", Parser.parse(parser, url));
}

function testLiteralPartialPath() {
  let parser = Parser.s("profile");
  let url = Url.fromString("/profile/extra");
  assertNone("s: rejects partial match with extra path", Parser.parse(parser, url));
}

function testTop() {
  let root = Url.fromString("/");
  let notRoot = Url.fromString("/page");
  assertSome("top: matches root", Parser.parse(Parser.top, root));
  assertNone("top: rejects non-root", Parser.parse(Parser.top, notRoot));
}

function testStr() {
  let url = Url.fromString("/anything");
  let result = Parser.parse(Parser.str, url);
  assertEq("str: captures segment", result, "anything");
}

function testInt() {
  let url42 = Url.fromString("/42");
  let urlText = Url.fromString("/abc");
  assertEq("int: parses integer", Parser.parse(Parser.int, url42), 42);
  assertNone("int: rejects non-integer", Parser.parse(Parser.int, urlText));
}

function testCustom() {
  let urlValid = Url.fromString("/abc123");
  let urlTooLong = Url.fromString("/thisstringiswaytoolongtobevalid");
  Url.fromString("/");
  let result = Parser.parse(parser, urlValid);
  if (result !== undefined) {
    assertEq("custom: parses valid ID", result._0, "abc123");
  } else {
    console.error("[FAIL] custom: expected valid parse");
  }
  assertNone("custom: rejects invalid", Parser.parse(parser, urlTooLong));
}

function testAndThen() {
  let parser = Parser.andThen(Parser.s("user"), Parser.int);
  let url = Url.fromString("/user/42");
  let result = Parser.parse(parser, url);
  assertEq("andThen: sequences parsers", result, [
    undefined,
    42
  ]);
}

function testAndThenOperator() {
  let parser = Parser.andThen(Parser.s("user"), Parser.int);
  let url = Url.fromString("/user/42");
  let result = Parser.parse(parser, url);
  assertEq("</>: operator form works", result, [
    undefined,
    42
  ]);
}

function testMap() {
  let parser = Parser.map(Parser.andThen(Parser.s("user"), Parser.int), param => ({
    TAG: "User",
    _0: param[1]
  }));
  let url = Url.fromString("/user/42");
  let result = Parser.parse(parser, url);
  assertEq("map: transforms result", result, {
    TAG: "User",
    _0: 42
  });
}

function testOneOf() {
  let parser = Parser.oneOf([
    Parser.map(Parser.top, () => "Home"),
    Parser.map(Parser.s("profile"), () => "Profile"),
    Parser.map(Parser.andThen(Parser.s("user"), Parser.int), param => ({
      TAG: "User",
      _0: param[1]
    }))
  ]);
  assertEq("oneOf: matches first (home)", Parser.parse(parser, Url.fromString("/")), "Home");
  assertEq("oneOf: matches second (profile)", Parser.parse(parser, Url.fromString("/profile")), "Profile");
  assertEq("oneOf: matches third (user)", Parser.parse(parser, Url.fromString("/user/5")), {
    TAG: "User",
    _0: 5
  });
  assertNone("oneOf: no match", Parser.parse(parser, Url.fromString("/unknown")));
}

function testOptional() {
  let parser = Parser.andThen(Parser.s("page"), Parser.optional(Parser.int));
  let withInt = Url.fromString("/page/5");
  Url.fromString("/page");
  let result = Parser.parse(parser, withInt);
  assertEq("optional: with value", result, [
    undefined,
    5
  ]);
}

function testQuery() {
  let parser = Parser.andThen(Parser.s("search"), Parser.query("q"));
  let withQuery = Url.fromString("/search?q=hello");
  let withoutQuery = Url.fromString("/search");
  let result1 = Parser.parse(parser, withQuery);
  assertEq("query: with param", result1, [
    undefined,
    "hello"
  ]);
  let result2 = Parser.parse(parser, withoutQuery);
  assertEq("query: without param", result2, [
    undefined,
    undefined
  ]);
}

function testQueryInt() {
  let parser = Parser.andThen(Parser.s("list"), Parser.queryInt("page"));
  let withInt = Url.fromString("/list?page=5");
  let withText = Url.fromString("/list?page=abc");
  let without = Url.fromString("/list");
  assertEq("queryInt: with int", Parser.parse(parser, withInt), [
    undefined,
    5
  ]);
  assertEq("queryInt: with non-int", Parser.parse(parser, withText), [
    undefined,
    undefined
  ]);
  assertEq("queryInt: without param", Parser.parse(parser, without), [
    undefined,
    undefined
  ]);
}

function testQueryRequired() {
  let parser = Parser.andThen(Parser.s("search"), Parser.queryRequired("q"));
  let withQuery = Url.fromString("/search?q=hello");
  let withoutQuery = Url.fromString("/search");
  assertEq("queryRequired: with param", Parser.parse(parser, withQuery), [
    undefined,
    "hello"
  ]);
  assertNone("queryRequired: without param fails", Parser.parse(parser, withoutQuery));
}

function testNestedRoutes() {
  let subParser = Parser.oneOf([
    Parser.map(Parser.s("a"), () => "SubA"),
    Parser.map(Parser.s("b"), () => "SubB"),
    Parser.map(Parser.s("c"), () => "SubC")
  ]);
  let parser$1 = Parser.map(Parser.andThen(Parser.andThen(Parser.s("item"), parser), subParser), param => ({
    TAG: "Nested",
    _0: param[0][1],
    _1: param[1]
  }));
  let urlA = Url.fromString("/item/xyz/a");
  let urlB = Url.fromString("/item/xyz/b");
  Url.fromString("/item/xyz/c");
  let urlNoSub = Url.fromString("/item/xyz");
  let urlInvalidSub = Url.fromString("/item/xyz/d");
  let match = Parser.parse(parser$1, urlA);
  if (typeof match === "object" && match.TAG === "Nested") {
    switch (match._1) {
      case "SubA" :
        assertEq("nested: /item/xyz/a", match._0._0, "xyz");
        break;
      case "SubB" :
      case "SubC" :
        console.error("[FAIL] nested: /item/xyz/a failed");
        break;
    }
  } else {
    console.error("[FAIL] nested: /item/xyz/a failed");
  }
  let match$1 = Parser.parse(parser$1, urlB);
  if (typeof match$1 === "object" && match$1.TAG === "Nested") {
    switch (match$1._1) {
      case "SubB" :
        console.log("[PASS] nested: /item/xyz/b");
        break;
      case "SubA" :
      case "SubC" :
        console.error("[FAIL] nested: /item/xyz/b failed");
        break;
    }
  } else {
    console.error("[FAIL] nested: /item/xyz/b failed");
  }
  assertNone("nested: no sub-route", Parser.parse(parser$1, urlNoSub));
  assertNone("nested: invalid sub-route", Parser.parse(parser$1, urlInvalidSub));
}

function testFullRouter() {
  let subParser = Parser.oneOf([
    Parser.map(Parser.s("a"), () => "SubA"),
    Parser.map(Parser.s("b"), () => "SubB"),
    Parser.map(Parser.top, () => "SubA")
  ]);
  let router = Parser.oneOf([
    Parser.map(Parser.top, () => "Home"),
    Parser.map(Parser.s("profile"), () => "Profile"),
    Parser.map(Parser.andThen(Parser.s("user"), Parser.int), param => ({
      TAG: "User",
      _0: param[1]
    })),
    Parser.map(Parser.andThen(Parser.s("item"), parser), param => ({
      TAG: "Item",
      _0: param[1]
    })),
    Parser.map(Parser.andThen(Parser.andThen(Parser.s("nested"), parser), subParser), param => ({
      TAG: "Nested",
      _0: param[0][1],
      _1: param[1]
    })),
    Parser.map(Parser.andThen(Parser.andThen(Parser.s("search"), Parser.queryRequired("q")), Parser.queryInt("page")), param => ({
      TAG: "Search",
      query: param[0][1],
      page: param[1]
    }))
  ]);
  console.log("\n-- Full Router Tests --");
  assertEq("router: /", Parser.parse(router, Url.fromString("/")), "Home");
  assertEq("router: /profile", Parser.parse(router, Url.fromString("/profile")), "Profile");
  assertEq("router: /user/123", Parser.parse(router, Url.fromString("/user/123")), {
    TAG: "User",
    _0: 123
  });
  let match = Parser.parse(router, Url.fromString("/item/abc"));
  if (typeof match === "object" && match.TAG === "Item") {
    assertEq("router: /item/abc", match._0._0, "abc");
  } else {
    console.error("[FAIL] router: /item/abc failed");
  }
  let match$1 = Parser.parse(router, Url.fromString("/nested/xyz/b"));
  if (typeof match$1 === "object" && match$1.TAG === "Nested") {
    switch (match$1._1) {
      case "SubB" :
        assertEq("router: /nested/xyz/b", match$1._0._0, "xyz");
        break;
      case "SubA" :
      case "SubC" :
        console.error("[FAIL] router: /nested/xyz/b failed");
        break;
    }
  } else {
    console.error("[FAIL] router: /nested/xyz/b failed");
  }
  let match$2 = Parser.parse(router, Url.fromString("/search?q=hello&page=2"));
  if (typeof match$2 === "object" && match$2.TAG === "Search") {
    assertEq("router: search query", match$2.query, "hello");
    assertEq("router: search page", match$2.page, 2);
  } else {
    console.error("[FAIL] router: /search failed");
  }
  assertNone("router: unknown path", Parser.parse(router, Url.fromString("/unknown")));
}

function testParsePartial() {
  let parser = Parser.s("prefix");
  let url = Url.fromString("/prefix/extra/segments");
  assertNone("parse: rejects extra segments", Parser.parse(parser, url));
  assertSome("parsePartial: allows extra segments", Parser.parsePartial(parser, url));
}

function testEmptyOneOf() {
  let parser = Parser.oneOf([]);
  let url = Url.fromString("/anything");
  assertNone("oneOf: empty array matches nothing", Parser.parse(parser, url));
}

function testChainedAndThen() {
  let parser = Parser.map(Parser.andThen(Parser.andThen(Parser.andThen(Parser.s("a"), Parser.s("b")), Parser.s("c")), Parser.str), param => param[1]);
  let url = Url.fromString("/a/b/c/value");
  assertEq("chained andThen: deep nesting", Parser.parse(parser, url), "value");
}

function runAll() {
  console.log("=== Parser Module Tests ===");
  console.log("\n-- Basic Parsers --");
  testLiteralMatch();
  testLiteralNoMatch();
  testLiteralPartialPath();
  testTop();
  testStr();
  testInt();
  testCustom();
  console.log("\n-- Combinators --");
  testAndThen();
  testAndThenOperator();
  testMap();
  testOneOf();
  testOptional();
  console.log("\n-- Query Parameters --");
  testQuery();
  testQueryInt();
  testQueryRequired();
  console.log("\n-- Nested Routes --");
  testNestedRoutes();
  console.log("\n-- Full Router --");
  testFullRouter();
  console.log("\n-- parsePartial --");
  testParsePartial();
  console.log("\n-- Edge Cases --");
  testEmptyOneOf();
  testChainedAndThen();
  console.log("\n=== Parser Tests Complete ===");
}

runAll();

export {
  assertEq,
  assertSome,
  assertNone,
  TestId,
  testLiteralMatch,
  testLiteralNoMatch,
  testLiteralPartialPath,
  testTop,
  testStr,
  testInt,
  testCustom,
  testAndThen,
  testAndThenOperator,
  testMap,
  testOneOf,
  testOptional,
  testQuery,
  testQueryInt,
  testQueryRequired,
  testNestedRoutes,
  testFullRouter,
  testParsePartial,
  testEmptyOneOf,
  testChainedAndThen,
  runAll,
}
/* parser Not a pure module */
