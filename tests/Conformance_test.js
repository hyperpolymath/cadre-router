// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Url from "../src/client/Url.js";
import * as Parser from "../src/client/Parser.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as RouteBuilder from "../src/client/RouteBuilder.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

let passed = {
  contents: 0
};

let failed = {
  contents: 0
};

function assert_(name, condition) {
  if (condition) {
    passed.contents = passed.contents + 1 | 0;
    console.log(`[PASS] ` + name);
  } else {
    failed.contents = failed.contents + 1 | 0;
    console.error(`[FAIL] ` + name);
  }
}

function assertEq(name, actual, expected) {
  if (Primitive_object.equal(actual, expected)) {
    passed.contents = passed.contents + 1 | 0;
    console.log(`[PASS] ` + name);
  } else {
    failed.contents = failed.contents + 1 | 0;
    console.error(`[FAIL] ` + name);
    console.error(`  Expected: ` + Belt_Option.getWithDefault(JSON.stringify(expected), "?"));
    console.error(`  Actual:   ` + Belt_Option.getWithDefault(JSON.stringify(actual), "?"));
  }
}

function summary() {
  let total = passed.contents + failed.contents | 0;
  console.log("");
  console.log(`=== Summary: ` + String(passed.contents) + `/` + String(total) + ` passed ===`);
  if (failed.contents > 0) {
    console.error(String(failed.contents) + ` tests failed`);
    return;
  }
}

function testUrlParsingConformance() {
  console.log("\n--- URL Parsing Conformance (RFC 3986) ---");
  let url1 = Url.fromString("/");
  assertEq("root path", url1.path, /* [] */0);
  let url2 = Url.fromString("/foo");
  assertEq("single segment", url2.path, {
    hd: "foo",
    tl: /* [] */0
  });
  let url3 = Url.fromString("/foo/bar/baz");
  assertEq("multiple segments", url3.path, {
    hd: "foo",
    tl: {
      hd: "bar",
      tl: {
        hd: "baz",
        tl: /* [] */0
      }
    }
  });
  let url4 = Url.fromString("/foo/");
  assertEq("trailing slash normalized", url4.path, {
    hd: "foo",
    tl: /* [] */0
  });
  let url5 = Url.fromString("/search?q=hello");
  assertEq("query param exists", Belt_MapString.get(url5.query, "q"), "hello");
  let url6 = Url.fromString("/search?a=1&b=2&c=3");
  assertEq("multiple query params a", Belt_MapString.get(url6.query, "a"), "1");
  assertEq("multiple query params b", Belt_MapString.get(url6.query, "b"), "2");
  assertEq("multiple query params c", Belt_MapString.get(url6.query, "c"), "3");
  let url7 = Url.fromString("/page#section");
  assertEq("fragment parsed", url7.fragment, "section");
  let url8 = Url.fromString("/page?q=x#section");
  assertEq("query with fragment", Belt_MapString.get(url8.query, "q"), "x");
  assertEq("fragment with query", url8.fragment, "section");
  let url9 = Url.fromString("");
  assertEq("empty string path", url9.path, /* [] */0);
  let url10 = Url.fromString("?q=test");
  assertEq("query only", Belt_MapString.get(url10.query, "q"), "test");
  let url11 = Url.fromString("#anchor");
  assertEq("fragment only", url11.fragment, "anchor");
  let url12 = Url.fromString("/search?q=hello%20world");
  assertEq("url encoded space", Belt_MapString.get(url12.query, "q"), "hello world");
}

let testParser = Parser.oneOf([
  Parser.map(Parser.top, () => "Home"),
  Parser.map(Parser.andThen(Parser.s("user"), Parser.int), param => ({
    TAG: "User",
    _0: param[1]
  })),
  Parser.map(Parser.andThen(Parser.s("article"), Parser.str), param => ({
    TAG: "Article",
    _0: param[1]
  })),
  Parser.map(Parser.andThen(Parser.andThen(Parser.s("nested"), Parser.int), Parser.str), param => ({
    TAG: "Nested",
    _0: param[0][1],
    _1: param[1]
  })),
  Parser.map(Parser.andThen(Parser.andThen(Parser.s("search"), Parser.queryRequired("q")), Parser.queryInt("page")), param => ({
    TAG: "Search",
    _0: param[0][1],
    _1: param[1]
  }))
]);

function testParserConformance() {
  console.log("\n--- Parser Combinator Conformance ---");
  assertEq("home exact", Parser.parse(testParser, Url.fromString("/")), "Home");
  assertEq("user exact", Parser.parse(testParser, Url.fromString("/user/42")), {
    TAG: "User",
    _0: 42
  });
  assertEq("article exact", Parser.parse(testParser, Url.fromString("/article/hello-world")), {
    TAG: "Article",
    _0: "hello-world"
  });
  assertEq("nested route", Parser.parse(testParser, Url.fromString("/nested/123/alice")), {
    TAG: "Nested",
    _0: 123,
    _1: "alice"
  });
  assertEq("search with query", Parser.parse(testParser, Url.fromString("/search?q=test")), {
    TAG: "Search",
    _0: "test",
    _1: undefined
  });
  assertEq("search with page", Parser.parse(testParser, Url.fromString("/search?q=test&page=5")), {
    TAG: "Search",
    _0: "test",
    _1: 5
  });
  assertEq("unknown path", Parser.parse(testParser, Url.fromString("/unknown")), undefined);
  assertEq("partial match rejected", Parser.parse(testParser, Url.fromString("/user")), undefined);
  assertEq("extra segments rejected", Parser.parse(testParser, Url.fromString("/user/42/extra")), undefined);
  assertEq("zero id", Parser.parse(testParser, Url.fromString("/user/0")), {
    TAG: "User",
    _0: 0
  });
  assertEq("negative id", Parser.parse(testParser, Url.fromString("/user/-5")), {
    TAG: "User",
    _0: -5
  });
  assertEq("non-numeric rejected", Parser.parse(testParser, Url.fromString("/user/abc")), undefined);
  let ambiguousParser = Parser.oneOf([
    Parser.map(Parser.s("a"), () => "first"),
    Parser.map(Parser.s("a"), () => "second")
  ]);
  assertEq("first match wins", Parser.parse(ambiguousParser, Url.fromString("/a")), "first");
}

function routeToString(route) {
  if (typeof route !== "object") {
    return "/";
  }
  switch (route.TAG) {
    case "User" :
      return "/user/" + String(route._0);
    case "Article" :
      return "/article/" + route._0;
    case "Nested" :
      return "/nested/" + String(route._0) + "/" + route._1;
    case "Search" :
      let page = route._1;
      return "/search?q=" + route._0 + (
        page !== undefined ? "&page=" + String(page) : ""
      );
  }
}

function testCrdtIdempotence() {
  console.log("\n--- CRDT Claim: Idempotence ---");
  console.log("Property: parse(url) = parse(parse(url) |> serialize)");
  let urls = [
    "/",
    "/user/42",
    "/article/hello-world",
    "/nested/123/alice",
    "/search?q=test",
    "/search?q=test&page=5"
  ];
  Belt_Array.forEach(urls, urlStr => {
    let url = Url.fromString(urlStr);
    let parsed1 = Parser.parse(testParser, url);
    if (parsed1 !== undefined) {
      let serialized = routeToString(parsed1);
      let url2 = Url.fromString(serialized);
      let parsed2 = Parser.parse(testParser, url2);
      return assertEq(`idempotent: ` + urlStr, parsed1, parsed2);
    }
    console.log(`[SKIP] ` + urlStr + ` (no match)`);
  });
}

function testCrdtDeterminism() {
  console.log("\n--- CRDT Claim: Determinism ---");
  console.log("Property: parse(url) called N times = same result");
  let urls = [
    "/",
    "/user/42",
    "/article/test",
    "/unknown"
  ];
  Belt_Array.forEach(urls, urlStr => {
    let url = Url.fromString(urlStr);
    let results = Belt_Array.map(Belt_Array.make(10, undefined), () => Parser.parse(testParser, url));
    let first = Belt_Array.get(results, 0);
    let allSame;
    if (first !== undefined) {
      let firstResult = Primitive_option.valFromOption(first);
      allSame = Belt_Array.every(results, r => Primitive_object.equal(r, firstResult));
    } else {
      allSame = false;
    }
    assert_(`deterministic: ` + urlStr, allSame);
  });
}

function testCrdtRoundtripConvergence() {
  console.log("\n--- CRDT Claim: Roundtrip Convergence ---");
  console.log("Property: parse(serialize(route)) = route");
  let routes = [
    "Home",
    {
      TAG: "User",
      _0: 1
    },
    {
      TAG: "User",
      _0: 42
    },
    {
      TAG: "User",
      _0: 0
    },
    {
      TAG: "User",
      _0: -1
    },
    {
      TAG: "Article",
      _0: "hello"
    },
    {
      TAG: "Article",
      _0: "hello-world"
    },
    {
      TAG: "Article",
      _0: "123"
    },
    {
      TAG: "Nested",
      _0: 1,
      _1: "a"
    },
    {
      TAG: "Nested",
      _0: 999,
      _1: "test-name"
    },
    {
      TAG: "Search",
      _0: "query",
      _1: undefined
    },
    {
      TAG: "Search",
      _0: "query",
      _1: 1
    },
    {
      TAG: "Search",
      _0: "query",
      _1: 100
    }
  ];
  Belt_Array.forEach(routes, route => {
    let serialized = routeToString(route);
    let url = Url.fromString(serialized);
    let parsed = Parser.parse(testParser, url);
    assertEq(`roundtrip: ` + serialized, parsed, route);
  });
}

function testCrdtUrlNormalization() {
  console.log("\n--- CRDT Claim: URL Normalization Convergence ---");
  console.log("Property: equivalent URLs parse to same route");
  let equivalentUrls = [
    [
      "/user/42",
      "/user/42/"
    ],
    [
      "/",
      ""
    ]
  ];
  Belt_Array.forEach(equivalentUrls, param => {
    let url2 = param[1];
    let url1 = param[0];
    let parsed1 = Parser.parse(testParser, Url.fromString(url1));
    let parsed2 = Parser.parse(testParser, Url.fromString(url2));
    assertEq(`normalize: "` + url1 + `" = "` + url2 + `"`, parsed1, parsed2);
  });
}

function testCrdtQueryOrderIndependence() {
  console.log("\n--- CRDT Claim: Query Parameter Order Independence ---");
  console.log("Property: ?a=1&b=2 = ?b=2&a=1");
  let url1 = Url.fromString("/search?q=test&page=5");
  let url2 = Url.fromString("/search?page=5&q=test");
  let parsed1 = Parser.parse(testParser, url1);
  let parsed2 = Parser.parse(testParser, url2);
  assertEq("query order independence", parsed1, parsed2);
}

let homeBuilder = RouteBuilder.build(RouteBuilder.end_, () => "BHome", route => {
  if (typeof route !== "object" && route === "BHome") {
    return Primitive_option.some(undefined);
  }
});

let profileBuilder = RouteBuilder.build(RouteBuilder.andThen(RouteBuilder.lit("profile"), RouteBuilder.end_), param => "BProfile", route => {
  if (typeof route !== "object" && route !== "BHome") {
    return [
      undefined,
      undefined
    ];
  }
});

let userBuilder = RouteBuilder.build(RouteBuilder.andThen(RouteBuilder.andThen(RouteBuilder.lit("user"), RouteBuilder.int()), RouteBuilder.end_), arg => ({
  TAG: "BUser",
  _0: arg[0][1]
}), route => {
  if (typeof route !== "object") {
    return;
  } else {
    return [
      [
        undefined,
        route._0
      ],
      undefined
    ];
  }
});

let builderRouter = RouteBuilder.oneOf([
  homeBuilder,
  profileBuilder,
  userBuilder
]);

function testBidirectionalConformance() {
  console.log("\n--- Bidirectional Route Conformance ---");
  let routes = [
    "BHome",
    "BProfile",
    {
      TAG: "BUser",
      _0: 42
    },
    {
      TAG: "BUser",
      _0: 0
    },
    {
      TAG: "BUser",
      _0: -1
    }
  ];
  Belt_Array.forEach(routes, route => {
    let urlStr = builderRouter.toString(route);
    if (urlStr !== undefined) {
      let url = Url.fromString(urlStr);
      let parsed = builderRouter.parse(url);
      if (parsed !== undefined) {
        return assertEq(`bidirectional: ` + urlStr, parsed, route);
      } else {
        failed.contents = failed.contents + 1 | 0;
        console.error(`[FAIL] bidirectional: ` + urlStr + ` - failed to parse`);
        return;
      }
    }
    failed.contents = failed.contents + 1 | 0;
    console.error(`[FAIL] bidirectional: failed to serialize route`);
  });
  let urls = [
    "/",
    "/profile",
    "/user/42",
    "/user/0"
  ];
  Belt_Array.forEach(urls, urlStr => {
    let url = Url.fromString(urlStr);
    let route = builderRouter.parse(url);
    if (route !== undefined) {
      let serialized = builderRouter.toString(route);
      if (serialized !== undefined) {
        let normalized = serialized === "/" ? "/" : serialized.replace(/\/$/, "");
        let urlNormalized = urlStr === "/" ? "/" : urlStr.replace(/\/$/, "");
        return assertEq(`serialize-parse: ` + urlStr, normalized, urlNormalized);
      }
      failed.contents = failed.contents + 1 | 0;
      console.error(`[FAIL] serialize-parse: ` + urlStr + ` - failed to serialize`);
      return;
    }
    console.log(`[SKIP] serialize-parse: ` + urlStr + ` (no match)`);
  });
}

function testEdgeCases() {
  console.log("\n--- Edge Cases and Boundaries ---");
  assertEq("empty string parses", Url.fromString("").path, /* [] */0);
  assertEq("whitespace path", Url.fromString("/  ").path, {
    hd: "  ",
    tl: /* [] */0
  });
  let urlWithDash = Url.fromString("/hello-world");
  assertEq("dash in path", urlWithDash.path, {
    hd: "hello-world",
    tl: /* [] */0
  });
  let urlWithUnderscore = Url.fromString("/hello_world");
  assertEq("underscore in path", urlWithUnderscore.path, {
    hd: "hello_world",
    tl: /* [] */0
  });
  let urlWithDot = Url.fromString("/file.txt");
  assertEq("dot in path", urlWithDot.path, {
    hd: "file.txt",
    tl: /* [] */0
  });
  let urlNumeric = Url.fromString("/123/456");
  assertEq("numeric path segments", urlNumeric.path, {
    hd: "123",
    tl: {
      hd: "456",
      tl: /* [] */0
    }
  });
  let longPath = "/" + Belt_Array.make(50, "segment").join("/");
  let urlLong = Url.fromString(longPath);
  assertEq("long path segment count", Belt_List.length(urlLong.path), 50);
  let urlEmptyValue = Url.fromString("/path?key=");
  assertEq("empty query value", Belt_MapString.get(urlEmptyValue.query, "key"), "");
  let urlNoValue = Url.fromString("/path?key");
  assertEq("query key only", Belt_MapString.get(urlNoValue.query, "key"), "");
  let urlMultiSlash = Url.fromString("//foo//bar//");
  assert_("multi-slash normalized", Belt_List.length(urlMultiSlash.path) <= 2);
}

function runAll() {
  console.log("\n========================================");
  console.log("  CONFORMANCE TESTS & CRDT STATE CLAIMS");
  console.log("========================================");
  passed.contents = 0;
  failed.contents = 0;
  testUrlParsingConformance();
  testParserConformance();
  testCrdtIdempotence();
  testCrdtDeterminism();
  testCrdtRoundtripConvergence();
  testCrdtUrlNormalization();
  testCrdtQueryOrderIndependence();
  testBidirectionalConformance();
  testEdgeCases();
  summary();
  console.log("\n========================================");
  console.log("  CONFORMANCE TESTS COMPLETE");
  console.log("========================================\n");
}

runAll();

export {
  passed,
  failed,
  assert_,
  assertEq,
  summary,
  testUrlParsingConformance,
  testParser,
  testParserConformance,
  routeToString,
  testCrdtIdempotence,
  testCrdtDeterminism,
  testCrdtRoundtripConvergence,
  testCrdtUrlNormalization,
  testCrdtQueryOrderIndependence,
  homeBuilder,
  profileBuilder,
  userBuilder,
  builderRouter,
  testBidirectionalConformance,
  testEdgeCases,
  runAll,
}
/* testParser Not a pure module */
